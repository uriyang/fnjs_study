<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>5. 실전코드조각-1</title>

    <script src="./js/partial.js"></script>
    <script src="./js/functional.js"></script>

</head>
<body>

<script>
    var users3 = [
        { id: 101, name: 'ID' },
        { id: 102, name: 'BJ' },
        { id: 103, name: 'PJ' },
        { id: 104, name: 'HA' },
        { id: 105, name: 'JE' },
        { id: 106, name: 'JI' },
    ];

    var posts = [
        { id: 201, body: '내용1', user_id: 101 },
        { id: 202, body: '내용2', user_id: 102 },
        { id: 203, body: '내용3', user_id: 103 },
        { id: 204, body: '내용4', user_id: 104 },
        { id: 205, body: '내용5', user_id: 101 },
    ];

    var comments = [
        { id: 301, body: '댓글1', user_id: 105, post_id: 201 },
        { id: 302, body: '댓글2', user_id: 104, post_id: 201 },
        { id: 303, body: '댓글3', user_id: 104, post_id: 202 },
        { id: 304, body: '댓글4', user_id: 105, post_id: 203 },
        { id: 305, body: '댓글5', user_id: 106, post_id: 204 },
        { id: 306, body: '댓글6', user_id: 106, post_id: 204 },
        { id: 307, body: '댓글7', user_id: 102, post_id: 205 },
        { id: 308, body: '댓글8', user_id: 103, post_id: 204 },
        { id: 309, body: '댓글9', user_id: 103, post_id: 202 },
        { id: 310, body: '댓글10', user_id: 105, post_id: 201 },
    ];

/** 1. 특정인의 posts의 모든 comments 거르기 **/
/*
user.id === 101 로 걸러지는 값
 - { id: 201, body: '내용1', user_id: 101 },
   { id: 205, body: '내용5', user_id: 101 }

201, 205 가 id 인 post 가 뽑히고
comments 에서 post 의 id 가 201, 205 인 comment 만 찾아낸다.

_.go(
    _.filter(posts, function (post) { return post.user_id == 101; }), // 특정인의 posts 찾음
    function (posts) { // 이후, 찾아낸 특정인의 posts 를 순회하면서
        return _.filter(comments, function(comment) { //  comments 중에
            return _.find(posts, function (post) { // 찾아낸 특정인의 post 에 삽입되어있는 comment 를 찾음
                return post.id === comment.post_id;
            });
        });
    },
    console.log
);
*/

/*
// -> 좀 더 개선해보자면
// ex. contains)
// _.contain([1, 2, 5, 10], 5); // true
//           [1, 2, 5, 10], 3); // false
_.go(
    // 특정인의 posts 찾음
    // _.filter or _.where 사용
    _.filter(posts, function (post) { return post.user_id == 101; }),
    // _.where(posts, { user_id: 101 }),

    // post 의 id만 따로 mapping 함
    // _.map or _.pluck 사용
    _.map(function (post) { return post.id; }),
    // _.pluck('id'),

    function (post_ids) { // 이후, post_id 배열을 순회하면서
        return _.filter(comments, function(comment) {
            return _.contains(post_ids, comment.post_id); // post_id 배열 중에 해당 post_id 의 comment 가 있는 지 확인
        });
    },
    console.log
);
*/

/** 2. 특정인의 posts에 comments를 단 친구의 이름들 뽑기 **/

/*

// ex. uniq)
// _.uniq(['JE', 'HA', 'BJ', 'JE']); // ['JE', 'HA', 'BJ]
_.go(
    _.where(posts, { user_id: 101 }),
    _.pluck('id'),
    function (post_ids) {
        return _.filter(comments, function(comment) {
            return _.contains(post_ids, comment.post_id);
        });
    },
    _.map(function (comment) {
        return _.find(users3, function (user) {
            return user.id == comment.user_id;
        }).name;
    }),
    _.uniq,
    console.log
);

*/

/** 1, 2번 중복코드 제거 **/

function posts_by(attr) {
    return _.where(posts, attr);
}

// post 를 기반으로 comment 를 꺼낸다.
var comments_by_posts = _.pipe(
    _.pluck('id'),
    function (post_ids) {
        return _.filter(comments, function(comment) {
            return _.contains(post_ids, comment.post_id);
        });
    }
);

/** 최종적으로 1번의 답이 되는 코드 **/
var f1 = _.pipe( posts_by, comments_by_posts );
// console.log(f1({ user_id: 101 }));

/** 최종적으로 2번의 답이 되는 코드 **/
var comments_to_user_names = _.map(function (comment) {
    return _.find(users3, function (user) {
        return user.id == comment.user_id;
    }).name;
});

var f2 = _.pipe(
    f1,
    comments_to_user_names,
    _.uniq
);
// console.log(f2({ user_id: 101 }));

/*
_.go({ user_id: 101 },
    posts_by,
    comments_by_posts,
    _.map(function (comment) {
        return _.find(users3, function (user) {
            return user.id == comment.user_id;
        }).name;
    }),
    _.uniq,
    console.log
);

*/

/** 3. 특정인의 posts에 comments를 단 친구들 카운트 정보 **/
/*
_.go({ user_id: 101 },
    posts_by,
    comments_by_posts,
    _.map(function (comment) {
        return _.find(users3, function (user) {
            return user.id == comment.user_id;
        }).name;
    }),
    _.count_by,
    console.log
);
*/

/** 최종적으로 3번의 답이 되는 코드 **/
var f3 = _.pipe(
    f1,
    comments_to_user_names,
    _.count_by,
);
// console.log(f3({ user_id: 101 }));


/** 4. 특정인이 comment를 단 posts 거르기(찾아내기) **/
/*
_.go(
    _.where(comments, { user_id: 105 }),
    _.pluck('post_id'),
    _.uniq,
    function(post_ids) {
        return _.filter(posts, function (post) {
            return _.contains(post_ids, post.id);
        });
    },
    console.log
);
*/


/** 섹션5. 실전코드조각2 효율 높이기 **/

/** 5. users + posts + comments (index_by 와 group_by로 효율높이기) **/

/** 1) user 들이 추가 된 comments 를 만듬. 단, 원본 데이터의 변형은 하지 않음 **/
// index_by를 사용하지 않으면 매번 for loop 을 수행하게 되므로 효율이 떨어짐
// 고로 미리 for loop 를 수행하여 id 를 기준으로 key 값을 생성하도록 함
var indexed_user_id = _.index_by(users3, 'id');
var comments2 = _.go(
    comments,
    _.map(function (comment) {
        // extends 를 사용하여 comments2 내부 데이터와 comment(원본)이 다르게끔
        return _.extend({
            // user: _.find(users3, function (user) {
            //     return comment.user_id == user.id;
            // })
            user: indexed_user_id[comment.user_id]
        }, comment);
    }),
    _.group_by('post_id'),
);
console.log(comments2);


/** 2) comment 들이 추가 된 posts 를 만듬. 단, 원본 데이터의 변형은 하지 않음 **/
// 위와 마찬가지로 효율성을 높이며, index_by 가 아닌 group_by 사용(post_id 가 key가 됨)
var posts2 = _go(
    posts,
    _.map(function (post) {
        return _.extend({
            comments: comments2[post.id] || [],
            user: indexed_user_id[post.user_id]
        }, post);
    }),
);

var posts3 = _.group_by(posts2, 'user_id');
console.log(posts3);

/** 3) comment 들이 추가 된 posts 를 만듬. 단, 원본 데이터의 변형은 하지 않음 **/
// 여기서 indexed_user_id 는 Object 지만 map, each 함수는 Object도 순회할 수 있으므로 가능함

/*
var users4 = _.map(indexed_user_id, function (user) {
    // user.posts = _.filter(posts3, function (post) {
    //     return post.user_id == user.id;
    // })

    // 위에 처럼 user.posts 를 직접 변경하게 되면 각 value 간에 참조가
    // 순회되어 JSON.stringify 를 할 수 없다. 때문에 extends 를 사용함
    return _.extend({
        posts:  _.filter(posts3, function (post) {
            return post.user_id == user.id;
        })
    }, user);
});
*/

var users4 = _.go(
    indexed_user_id,
    _.map(function (user) {
        return _.extend({
            posts: posts3[user.id] || []
        }, user);
    })
);
console.log(users4);

/** 5.1 특정인의 posts 의 모든 comments 거르기(1번과 동일하지만 다른 로직) **/
var user = users4[0];
_.go(
    user.posts,
    _.pluck('comments'),
    _.flatten,
    console.log
);

// 위의 pluck, flatten 을 한번에 하는 게 deep_pluck
// TODO 위에 pluck, flatten 쓴것과 deep_pluck 쓴것 결과가 다르다.. 해결해보자
console.log(_.deep_pluck(user, 'posts.comments'));



/** 5.2 특정인의 posts에 comments를 단 친구의 이름들 뽑기(2번과 동일하지만 다른 로직) **/
_.go(
    user.posts,
    _.pluck('comments'),
    _.flatten,

    _.pluck('user'),
    _.pluck('name'),
    _.uniq,

    console.log
);

console.log(_.uniq(_.deep_pluck(user, 'posts.comments.user.name')));

_.go(user, _.deep_pluck('posts.comments.user.name'), _.uniq, console.log);

/** 5.3 특정인의 posts에 comments를 단 친구들 카운트 정보(3번과 동일하지만 다른 로직) **/
_.go(
    user.posts,
    _.pluck('comments'),
    _.flatten,

    _.pluck('user'),
    _.pluck('name'),
    _.count_by,

    console.log
);

_.go(user, _.deep_pluck('posts.comments.user.name'), _.count_by, console.log);

/** 5.4 특정인이 comment를 단 posts 거르기(찾아내기)
 * (4번과 동일하지만 다른 로직) **/
// TODO 이것도 답이 좀 다르다(4번과 비교해서 틀린 곳 찾아내보자.. 아마 comments2 에 오류가 있는 것 같다)
console.log(
    _.filter(posts2, function (post) {
        return _.find(post.comments, function (comment) {
            return comment.user_id == 105;
        })
    })
);
</script>

</body>
</html>